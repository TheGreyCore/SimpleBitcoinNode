## Roadmap and current features

## Stage I summary - communal ledger model (deadline 2024-04-07)

By the end of stage I we have managed to create a centralized transaction API based on the simplified communal ledger model. The simplified communal ledger model
implies that each transaction consists of previous transaction outputs made to the sender and transaction outputs which define recipients and amount of tokens to transfer
under current transaction.

### About the communal ledger transaction model

Communal ledger model entails that there exists some kind of ledger keeping track of all transactions happening in the network. Right now under testing circumstances, we can
only assume that there exists one such ledger centrally hosted somewhere in the testing network. The ledger itself contains records of anonymized transactions, whose only bits of
deanonymizing information are cryptographic signatures and public keys that are used to validate said signatures. The only way to verify if the transaction is valid, is by
cryptographically validating each transaction output's signature. As of now that validation is performed by Bitcoin node itself.

Transactions are linked together with previous unspent transaction outputs and transaction outputs generated by the current transaction.

In order to illustrate current transaction model, lets for example, assume that Charlie sends 1.5 tokens to Bob and Alice sends 2.1 tokens to Bob.  
After receiving tokens, Bob wants to send 1.9 tokens to Alice.

To do so, his transaction has to consist of two inputs: 1.5 tokens received from Charlie and 2.1 tokens received by Alice.  
Bob's transaction consists of two outputs: 1.9 tokens sent to Alice and 1.7 tokens sent back to Bob.

### Current features and quickstart

Currently implemented features are:
* Database seeding with arbitrary transactions
* REST interface for querying about transactions where some public key (aka address) has been involved in either as a sender, receiver or both.
* `AsymmetricCryptographyService` interface for both backend and frontend

The simplest way to test out the project is by having it built by maven of which there exists a wrapper in the repository's root. If using Linux or MacOS:
```
$ ./mvnw package
```

If using Windows:
```
> .\mvnw.cmd package
```

After packaging the project you can run the built `.jar` file with, for example, following arguments:
```
seed 21000000 5 6
```

These arguments will then be used to seed the database with random transactions, as well as run the REST API server. The transactions are built as a tree like structure
where the first wallet gets to hold 21000000 freshly minted tokens. The owner of that wallet then sends his tokens to 5 new wallets, at max 1/5 of his total initial supply
of tokens per recipient. Then those wallets send their tokens to 5 new wallets and so on. The process repeats until the 6th level of the tree is reached, which means that in total
$5^6$ new transactions were generated.

## Stage II summary - transition to blockchain and DTOs (deadline 2024-04-28)

By the end of stage two we have done some refactoring to controller logic, namely adopted the usage
of *data transfer objects*. In addition, we have created an entry point to transition our current 
communal ledger model into a blockchain model. Right now, only blockchain data entities have been created 
along with a pseudo block data generation algorithm that generates random blocks (not mined, meaning that 
block hashes don't have n leading zero bits).

One of the goals for stage II was to implement a system (cron job) that automatically tries to construct
a new block after specified time intervals, which unfortunately has not been done yet.

### Blockchain transaction model

Blockchain transaction model mostly extends communal ledger model, in which each block essentially represents one such ledger. 
Blocks are chained next to other in a way where the hash of the previous block is used to calculate the hash of the next block. 
In order to be space efficient, blocks do not actually contain transaction entries as it was the case with communal ledger model
but transactions are used to form a Merkle tree (hash tree) whose root is then stored in the block header. Transactions whose outputs
have been consumed by other transactions can therefore be omitted.

The amount of transactions per block can very but for the scope of this project we will use 128 transactions to construct one block.
